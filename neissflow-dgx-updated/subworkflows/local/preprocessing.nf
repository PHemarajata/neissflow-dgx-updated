//
// Quality Trimming & Filtering, Adaptor Trimming, and QC Check
//
include { FASTP                 } from '../../modules/local/fastp/fastp'
include { PARSE_FASTP_REPORTS   } from '../../modules/local/fastp/parse_fastp'
include { COMBINE_FASTP_REPORTS } from '../../modules/local/fastp/combine_reports'
include { FASTP_QC_CHECK        } from '../../modules/local/fastp/fastp_qc'

workflow PREPROCESSING {
    take:
    reads          // channel: [ val(sample_name), [ reads ] ]
    prefix         // val(prefix)

    main:

    ch_versions = Channel.empty()

    //
    // Quality trimming & filtering and adaptor trimming with fastp
    //
    ch_fastq = Channel.empty()
    FASTP (
        reads
    )
    ch_fastq = FASTP.out.fastq_4_processing_files
    ch_versions = ch_versions.mix(FASTP.out.versions)

    //
    // Parse JSON report generated by fastp & report relevant FASTQ quality metrics 
    //
    ch_fastp_report = Channel.empty()
    PARSE_FASTP_REPORTS (
        FASTP.out.json_path
    )
    ch_fastp_report = PARSE_FASTP_REPORTS.out.tsv_path
    ch_versions = ch_versions.mix(PARSE_FASTP_REPORTS.out.versions)

    //
    // Combine reports for all samples into one report
    //
    COMBINE_FASTP_REPORTS (
        ch_fastp_report.collect(),
        prefix
    )
    ch_versions = ch_versions.mix(COMBINE_FASTP_REPORTS.out.versions)

    //
    // Perform QC check and create reports containing the passed & failed samples
    //
    FASTP_QC_CHECK (
        COMBINE_FASTP_REPORTS.out.fastp_report,
        prefix
    )
    ch_versions = ch_versions.mix(FASTP_QC_CHECK.out.versions)

    ch_qc = Channel.empty()
    ch_qc = FASTP_QC_CHECK.out
            .passed
            .splitCsv ( header:true, sep:'\t' )
            .map { row -> "${row.isolate}" }

    ch_fastq = ch_fastq
            .map { 
                meta, fastqs ->
                    [ meta, fastqs ]
            }
    ch_qc = ch_qc
            .map {
                meta ->
                    [ meta ]
            }

    ch_passed = Channel.empty()
    ch_passed = ch_fastq.join(ch_qc)

    emit:

    fastp_report        = COMBINE_FASTP_REPORTS.out.fastp_report        // channel:  fastp_report 
    fastp_json          = FASTP.out.json_path                           // channel:  [ val(sample_name), [ json_path ] ]

    passed              = FASTP_QC_CHECK.out.passed                     // channel: passed
    failed              = FASTP_QC_CHECK.out.failed                     // channel: failed

    trimmed_fastq_paths = ch_passed                                     // channel: [ val(sample_name), [ trimmed_fastq_paths ] ]

    versions            = ch_versions                                   // channel: [ versions.yml ]

}